<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="TypeScript.CSS">
    <title>Learn TypeScript</title>
</head>
<body>
    <nav id="sidebar">
      <h2>TypeScript</h2>
      <ul>
        <li><a class="nav-item" href="Introduction.html">Go back to About Website</a></li>
        <li><a class="nav-item" href="Javascript.html">Back to JavaScript</a></li>
        <li><a class="nav-item" href="#Introduction">Introduction</a></li>
        <li><a class="nav-item" href="#typescript_basics">TypeScript Basics</a></li>
        <li><a class="nav-item" href="#typescript_types">TypeScript Types</a></li>
        <li><a class="nav-item" href="#typescript_functions">TypeScript Functions</a></li>
        <li><a class="nav-item" href="#typescript_classes">TypeScript Classes</a></li>
        <li><a class="nav-item" href="#typescript_modules">TypeScript Modules</a></li>
        <li><a class="nav-item" href="#typescript_decorators">TypeScript Decorators</a></li>
        <li><a class="nav-item" href="#SettingUpTypeScriptEnvironment">Setting up TypeScript Environment</a></li>
        <li><a class="nav-item" href="#TypeScriptVariables">TypeScript Variables</a></li>
        <li><a class="nav-item" href="#TypeInferenceInTypeScript">Type Inference in TypeScript</a></li>
        <li><a class="nav-item" href="#ClassConstructorsInTypeScript">Class Constructors in TypeScript</a></li>
        <li><a class="nav-item" href="#AccessModifiersInTypeScript">Access Modifiers in TypeScript</a></li>
        <li><a class="nav-item" href="#PropertiesInTypeScript">Properties in TypeScript</a></li>
        <li><a class="nav-item" href="#InheritanceInTypeScript">Inheritance in TypeScript</a></li>
        <li><a class="nav-item" href="#AbstractClassesInTypeScript">Abstract Classes in TypeScript</a></li>
        <li><a class="nav-item" href="#ImplementingInterfaces">Interfaces in TypeScript</a></li>
        <li><a class="nav-item" href="#NamespacesInTypeScript">Namespaces in TypeScript</a></li>
        <li><a class="nav-item" href="#WorkingWithExternalLibrariesInTypeScript">Working with External Libraries in TypeScript</a></li>
        <li><a class="nav-item" href="#TypeDeclarationsInTypeScript">Type Declarations in TypeScript</a></li>
        <li><a class="nav-item" href="#TypeGuardsInTypeScript">Type Guards in TypeScript</a></li>
        <li><a class="nav-item" href="#UnionTypesInTypeScript">Union Types in TypeScript</a></li>
        <li><a class="nav-item" href="#IntersectionTypesInTypeScript">Intersection Types in TypeScript</a></li>
        <li><a class="nav-item" href="#TypeAliasesInTypeScript">Type Aliases in TypeScript</a></li>
        <li><a class="nav-item" href="#EnumerationsInTypeScript">Enumerations in TypeScript</a></li>
        <li><a class="nav-item" href="#LiteralTypesInTypeScript">Literal Types in TypeScript</a></li>
        <li><a class="nav-item" href="#GenericsInTypeScript">Generics in TypeScript</a></li>
        <li><a class="nav-item" href="#WorkingWithArraysInTypeScript">Working with Arrays in TypeScript</a></li>
        <li><a class="nav-item" href="#TupleTypesInTypeScript">Tuple Types in TypeScript</a></li>
        <li><a class="nav-item" href="#EnumsWithStringValuesInTypeScript">Enums with String Values in TypeScript</a></li>
        <li><a class="nav-item" href="#MixinsInTypeScript">Mixins in TypeScript</a></li>
        <li><a class="nav-item" href="#NamespacesAndModulesTogether">Namespaces and Modules Together</a></li>
        <li><a class="nav-item" href="#NamespacesVsModulesInTypeScript">Namespaces vs. Modules in TypeScript</a></li>
        <li><a class="nav-item" href="#UsingThirdPartyModulesInTypeScript">Using Third-Party Modules in TypeScript</a></li>
        <li><a class="nav-item" href="#DeclarationMergingInTypeScript">Declaration Merging in TypeScript</a></li>
        <li><a class="nav-item" href="#AmbientDeclarationsInTypeScript">Ambient Declarations in TypeScript</a></li>
        <li><a class="nav-item" href="#DeclarationFilesInTypeScript">Declaration Files in TypeScript</a></li>
        <li><a class="nav-item" href="#WorkingWithPromisesInTypeScript">Working with Promises in TypeScript</a></li>
        <li><a class="nav-item" href="#AsyncAwaitInTypeScript">Async/Await in TypeScript</a></li>
        <li><a class="nav-item" href="#UsingAsyncFunctionsInTypeScript">Using async Functions in TypeScript</a></li>
        <li><a class="nav-item" href="#ErrorHandlingInTypeScript">Error Handling in TypeScript</a></li>
        <li><a class="nav-item" href="#TypeCompatibilityinTypeScript">Type Compatibility in TypeScript</a></li>
        <li><a class="nav-item" href="#TypeInferenceWithUnionTypes">Type Inference with Union Types</a></li>
        <li><a class="nav-item" href="#AdvancedTypesInTypeScript">Advanced Types in TypeScript</a></li>
        <li><a class="nav-item" href="#ConditionalTypesInTypeScript">Conditional Types in TypeScript</a></li>
        <li><a class="nav-item" href="#IndexedAccessTypesInTypeScript">Indexed Access Types in TypeScript</a></li>
        <li><a class="nav-item" href="#MappedTypesInTypeScript">Mapped Types in TypeScript</a></li>
        <li><a class="nav-item" href="#UtilityTypesInTypeScript">Utility Types in TypeScript</a></li>
        <li><a class="nav-item" href="#PartialAndReadonlyTypes">Partial and Readonly Types</a></li>
        <li><a class="nav-item" href="#RequiredAndPickTypes">Required and Pick Types</a></li>
        <li><a class="nav-item" href="#ExcludeAndExtractTypes">Exclude and Extract Types</a></li>
        <li><a class="nav-item" href="#NonNullableAndParametersTypes">Non-Nullable and Parameters Types</a></li>
        <li><a class="nav-item" href="#OmitAndReturnTypeTypes">Omit and ReturnType Types</a></li>
        <li><a class="nav-item" href="#PolymorphicThisTypes">Polymorphic this Types</a></li>
        <li><a class="nav-item" href="#TypeCastingInTypeScript">Type Casting in TypeScript</a></li>
        <li><a class="nav-item" href="#TripleSlashDirectivesInTypeScript">Triple-Slash Directives in TypeScript</a></li>
        <li><a class="nav-item" href="#ConfiguringTsconfigJson">Configuring tsconfig.json</a></li>
        <li><a class="nav-item" href="#StrictNullChecksInTypeScript">Strict Null Checks in TypeScript</a></li>
        <li><a class="nav-item" href="#UsingTypeScriptWithReact">Using TypeScript with React</a></li>
        <li><a class="nav-item" href="#ReactWithTypeScriptProps">React with TypeScript Props</a></li>
        <li><a class="nav-item" href="#ReactWithTypeScriptState">React with TypeScript State</a></li>
        <li><a class="nav-item" href="#ReactWithTypeScriptHooks">React with TypeScript Hooks</a></li>
        <li><a class="nav-item" href="#ReactWithTypeScriptForms">React with TypeScript Forms</a></li>
        <li><a class="nav-item" href="#ReactWithTypeScriptContext">React with TypeScript Context</a></li>
        <li><a class="nav-item" href="#UsingTypeScriptWithNodejs">Using TypeScript with Node.js</a></li>
        <li><a class="nav-item" href="#IntegratingTypeScriptWithExpressjs">Integrating TypeScript with Express.js</a></li>
      <li><a class="nav-item" href="Python.html">Learn Python</a></li>

      </ul>
    </nav>
    <main id="documentation">
      <section id="Introduction">
        <h2>Introduction</h2>
        <article>
          <p>
            TypeScript is a strongly-typed superset of JavaScript that compiles to plain JavaScript. It adds static
            typing and various other features to help developers write more reliable and maintainable code. TypeScript
            code is compiled to JavaScript, making it compatible with all modern browsers and platforms.
          </p>
          <h3>TypeScript Document</h3>
          <pre>
    const greeting: string = "Hello, TypeScript!";
    console.log(greeting); // Output: Hello, TypeScript!
          </pre>
        </article>
      </section>
      <section id="typescript_basics">
        <h2>TypeScript Basics</h2>
        <article>
          <p>
            TypeScript supports all JavaScript features and syntax. It introduces static types, which help catch type
            errors during development and provide better code documentation.
          </p>
          <pre>
    // TypeScript variables with types
    let message: string = "Hello, TypeScript!";
    let num: number = 42;
    let isDone: boolean = false;
    </pre>
        </article>
      </section>
      <section id="typescript_types">
        <h2>TypeScript Types</h2>
        <article>
          <p>
            TypeScript provides various built-in types such as string, number, boolean, array, tuple, enum, any, null,
            undefined, void, and never. Additionally, it supports custom type declarations using interfaces and
            classes.
          </p>
          <pre>
    // TypeScript arrays and tuples
    let fruits: string[] = ["apple", "banana", "orange"];
    let person: [string, number] = ["John", 30];
    </pre>
        </article>
      </section>
      <section id="typescript_functions">
        <h2>TypeScript Functions</h2>
        <article>
          <p>
            Functions in TypeScript can have explicit return types and optional parameters. They can also be assigned
            to variables and passed as arguments to other functions.
          </p>
          <pre>
    // TypeScript function with return type
    function add(a: number, b: number): number {
      return a + b;
    }
  
    // TypeScript function with optional parameter
    function greet(name?: string): string {
      return name ? `Hello, ${name}!` : "Hello!";
    }
    </pre>
        </article>
      </section>
      <section id="typescript_classes">
        <h2>TypeScript Classes</h2>
        <article>
          <p>
            Classes in TypeScript allow you to define blueprints for objects. They can have properties, methods, and
            constructors. TypeScript supports inheritance, interfaces, and access modifiers (public, private, protected).
          </p>
          <pre>
    // TypeScript class with inheritance
    class Animal {
      name: string;
  
      constructor(name: string) {
        this.name = name;
      }
  
      makeSound() {
        console.log("Animal makes a sound.");
      }
    }
  
    class Dog extends Animal {
      makeSound() {
        console.log("Dog barks.");
      }
    }
  
    const dog = new Dog("Buddy");
    dog.makeSound(); // Output: Dog barks.
    </pre>
        </article>
      </section>
      <section id="typescript_modules">
        <h2>TypeScript Modules</h2>
        <article>
          <p>
            TypeScript supports modules, which allow you to organize your code into separate files and reuse them in
            other parts of the application. Modules can be imported and exported to create a modular code structure.
          </p>
          <pre>
    // TypeScript module exports
    export const PI = 3.14;
  
    export function add(a: number, b: number): number {
      return a + b;
    }
    </pre>
        </article>
      </section>
      <section id="typescript_decorators">
        <h2>TypeScript Decorators</h2>
        <article>
          <p>
            Decorators are a TypeScript feature used to modify classes, methods, or properties at design time. They are
            commonly used with frameworks like Angular to add metadata and behavior to components and services.
          </p>
          <pre>
    // TypeScript decorator example
    function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
      const originalMethod = descriptor.value;
      descriptor.value = function (...args: any[]) {
        console.log("Method called:", propertyKey);
        return originalMethod.apply(this, args);
      };
      return descriptor;
    }
  
    class Example {
      @log
      someMethod() {
        console.log("Hello from someMethod!");
      }
    }
  
    const instance = new Example();
    instance.someMethod();
    </pre>
        </article>
      </section>
    
   
      <section id="SettingUpTypeScriptEnvironment">
          <h2>Setting up TypeScript Environment</h2>
          <article>
              <p>
                  Setting up the TypeScript environment involves installing TypeScript, configuring the TypeScript
                  compiler options, and integrating TypeScript into your development workflow. To install TypeScript,
                  use npm or yarn:
              </p>
              <pre>
npm install -g typescript
              </pre>
              <p>
                  After installation, you can create a <code>tsconfig.json</code> file to configure compiler options.
                  This file specifies how TypeScript should compile your code. You can include options such as target
                  ECMAScript version, module system, and more.
              </p>
              <pre>
{
  "compilerOptions": {
      "target": "ES6",
      "module": "CommonJS",
      "outDir": "dist"
  }
}
              </pre>
              <p>
                  Once your environment is set up, you can use the TypeScript compiler to transpile your TypeScript
                  code into JavaScript. Run <code>tsc</code> command in your project directory to compile all
                  TypeScript files.
              </p>
          </article>
      </section>
      <section id="TypeScriptVariables">
          <h2>TypeScript Variables</h2>
          <article>
              <p>
                  TypeScript introduces static typing for variables. You can declare variables using <code>let</code>
                  or <code>const</code> keywords. Additionally, you can specify the variable type using a colon
                  followed by the type.
              </p>
              <pre>
let message: string = "Hello, TypeScript!";
let num: number = 42;
let isDone: boolean = false;
              </pre>
              <p>
                  In the example above, <code>message</code> is a variable of type <code>string</code>,
                  <code>num</code> is a variable of type <code>number</code>, and <code>isDone</code> is a variable
                  of type <code>boolean</code>.
              </p>
          </article>
      </section>
      <section id="TypeInferenceInTypeScript">
        <h2>Type Inference in TypeScript</h2>
        <article>
            <p>
                Type inference is a powerful feature in TypeScript that allows the compiler to automatically determine the
                type of a variable based on its value. This means you don't always have to explicitly annotate the type.
            </p>
            <pre>
    const myNumber = 42; // TypeScript infers the type as number
    const myText = "Hello"; // TypeScript infers the type as string
            </pre>
            <p>
                In this example, TypeScript infers that <code>myNumber</code> is of type <code>number</code> and
                <code>myText</code> is of type <code>string</code>.
            </p>
            <p>
                However, type inference is not always possible, especially when variables don't have an initial value or
                their types can't be determined unambiguously. In such cases, you can still provide explicit type
                annotations.
            </p>
            <pre>
    const myVariable: unknown = getValueFromExternalSource();
            </pre>
        </article>
    </section>
    <section id="ClassConstructorsInTypeScript">
        <h2>Class Constructors in TypeScript</h2>
        <article>
            <p>
                Constructors are special methods in TypeScript classes that are called when an instance of a class is
                created. Constructors are used to initialize the object's properties and perform setup operations.
            </p>
            <pre>
    class Person {
        name: string;
    
        constructor(name: string) {
            this.name = name;
        }
    }
    
    const person = new Person("John");
    console.log(person.name); // Output: John
            </pre>
            <p>
                In this example, the <code>Person</code> class has a constructor that takes a <code>name</code> parameter
                and assigns it to the <code>name</code> property of the instance. When you create a new <code>Person</code>
                object, you pass the name as an argument.
            </p>
            <p>
                Constructors can also have access modifiers like <code>public</code>, <code>private</code>, and
                <code>protected</code>, which control the visibility of the properties and methods.
            </p>
        </article>
    </section>
    <section id="AccessModifiersInTypeScript">
      <h2>Access Modifiers in TypeScript</h2>
      <article>
          <p>
              Access modifiers are keywords used in TypeScript to control the visibility and accessibility of class members
              (properties and methods). They help in enforcing encapsulation and provide a way to restrict access to certain
              parts of a class from outside code.
          </p>
          <p>
              TypeScript provides three main access modifiers:
          </p>
          <ul>
              <li><strong>public</strong>: Members marked as public can be accessed from anywhere, both inside and outside the class.</li>
              <li><strong>private</strong>: Members marked as private are only accessible from within the class where they are defined.</li>
              <li><strong>protected</strong>: Members marked as protected are accessible within the class and its subclasses, but not from outside code.</li>
          </ul>
          <pre>
  class Person {
      public name: string;      // Accessible everywhere
      private age: number;     // Accessible only within the class
      protected address: string; // Accessible within class and subclasses
  
      constructor(name: string, age: number, address: string) {
          this.name = name;
          this.age = age;
          this.address = address;
      }
  }
  
  const person = new Person("John", 30, "123 Main St");
  console.log(person.name);     // Accessible
  console.log(person.age);      // Error: 'age' is private
  console.log(person.address);  // Error: 'address' is protected
          </pre>
          <p>
              In this example, the <code>name</code> property has a <code>public</code> access modifier and is accessible
              from outside the class. The <code>age</code> property is marked as <code>private</code> and can only be
              accessed within the <code>Person</code> class. The <code>address</code> property is marked as
              <code>protected</code> and can be accessed within the <code>Person</code> class and its subclasses.
          </p>
      </article>
  </section>
  <section id="PropertiesInTypeScript">
    <h2>Properties in TypeScript</h2>
    <article>
        <p>
            Properties in TypeScript are used to store and represent data within a class. They are defined within a class
            and can have various access modifiers such as <code>public</code>, <code>private</code>, or
            <code>protected</code>. Properties allow you to store and retrieve values that are associated with an instance
            of a class.
        </p>
        <pre>
class Person {
    public name: string;      // Public property
    private age: number;     // Private property

    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }
}

const person = new Person("John", 30);
console.log(person.name);   // Accessing public property
console.log(person.age);    // Error: 'age' is private
        </pre>
        <p>
            In this example, the <code>Person</code> class has two properties: <code>name</code> (public) and <code>age</code>
            (private). The <code>name</code> property can be accessed from outside the class, while the <code>age</code> property
            can only be accessed within the class itself.
        </p>
    </article>
</section>

<section id="InheritanceInTypeScript">
    <h2>Inheritance in TypeScript</h2>
    <article>
        <p>
            Inheritance is a fundamental concept in object-oriented programming that allows you to create a new class based on
            an existing class. The new class inherits properties and behaviors (methods) from the parent class. In TypeScript,
            you can use the <code>extends</code> keyword to achieve inheritance.
        </p>
        <pre>
class Animal {
    protected name: string;

    constructor(name: string) {
        this.name = name;
    }

    makeSound() {
        console.log("Animal makes a sound");
    }
}

class Dog extends Animal {
    constructor(name: string) {
        super(name);
    }

    makeSound() {
        console.log("Dog barks");
    }
}

const dog = new Dog("Buddy");
dog.makeSound(); // Output: "Dog barks"
        </pre>
        <p>
            In this example, the <code>Dog</code> class inherits from the <code>Animal</code> class. The <code>Dog</code> class
            overrides the <code>makeSound</code> method to provide a different implementation.
        </p>
    </article>
</section>
<section id="AbstractClassesInTypeScript">
  <h2>Abstract Classes in TypeScript</h2>
  <article>
      <p>
          An abstract class is a class that cannot be instantiated directly and is meant to be used as a base for other classes.
          It can have abstract methods, which are methods without an implementation in the abstract class itself. Subclasses
          of an abstract class are required to provide implementations for these abstract methods.
      </p>
      <pre>
abstract class Shape {
  abstract area(): number;
}

class Circle extends Shape {
  radius: number;

  constructor(radius: number) {
      super();
      this.radius = radius;
  }

  area() {
      return Math.PI * this.radius * this.radius;
  }
}

const circle = new Circle(5);
console.log(circle.area()); // Output: 78.53981633974483
      </pre>
      <p>
          In this example, the <code>Shape</code> class is an abstract class with an abstract method <code>area</code>. The
          <code>Circle</code> class extends <code>Shape</code> and provides an implementation for the <code>area</code>
          method. Abstract classes can define common methods and properties that can be shared among their subclasses.
      </p>
  </article>
</section>

<section id="ImplementingInterfaces">
  <h2>Interfaces in TypeScript</h2>
  <article>
      <p>
          Interfaces define a contract for how classes or objects should be structured. They can specify method signatures,
          property names, and types. Classes that implement an interface must adhere to the structure defined by the interface.
      </p>
      <pre>
interface Employee {
  name: string;
  role: string;
  getDetails(): string;
}

class Manager implements Employee {
  name: string;
  role: string;

  constructor(name: string, role: string) {
      this.name = name;
      this.role = role;
  }

  getDetails() {
      return `${this.name} is a ${this.role}.`;
  }
}

const manager = new Manager("Alice", "Manager");
console.log(manager.getDetails()); // Output: "Alice is a Manager."
      </pre>
      <p>
          In this example, the <code>Employee</code> interface defines a contract for objects with <code>name</code>,
          <code>role</code>, and <code>getDetails</code> properties. The <code>Manager</code> class implements the
          <code>Employee</code> interface by providing implementations for these properties.
      </p>
  </article>
</section>
<section id="NamespacesInTypeScript">
  <h2>Namespaces in TypeScript</h2>
  <article>
      <p>
          Namespaces provide a way to organize code into logical groups. They prevent naming conflicts by allowing you to
          encapsulate related classes, interfaces, functions, and variables under a common namespace.
      </p>
      <pre>
namespace MathOperations {
  export function add(a: number, b: number): number {
      return a + b;
  }

  export function subtract(a: number, b: number): number {
      return a - b;
  }
}

const sum = MathOperations.add(5, 3);
console.log(sum); // Output: 8
      </pre>
      <p>
          In this example, the <code>MathOperations</code> namespace encapsulates the <code>add</code> and <code>subtract</code>
          functions. The <code>export</code> keyword allows these functions to be accessed outside the namespace.
      </p>
  </article>
</section>

<section id="WorkingWithExternalLibrariesInTypeScript">
  <h2>Working with External Libraries in TypeScript</h2>
  <article>
      <p>
          TypeScript allows you to use external JavaScript libraries and leverage their type information to provide better
          code analysis and error checking. This is achieved through declaration files (often with a <code>.d.ts</code>
          extension) that describe the types and structures of the existing JavaScript code.
      </p>
      <pre>
// Assuming you have an external library "lodash" installed
import * as _ from 'lodash';

const numbers = [1, 2, 3, 4, 5];
const sum = _.sum(numbers);
console.log(sum); // Output: 15
      </pre>
      <p>
          In this example, the <code>lodash</code> library is imported and used to calculate the sum of an array of numbers.
          TypeScript uses the declaration file for <code>lodash</code> to provide type information and help catch potential
          type-related errors.
      </p>
  </article>
</section>
     <section id="TypeDeclarationsInTypeScript">
  <h2>Type Declarations in TypeScript</h2>
  <article>
      <p>
          Type declarations are a powerful feature of TypeScript that allow you to describe the types of values that exist
          in your JavaScript code, even if you don't have the corresponding TypeScript source code. This is particularly
          useful when working with third-party libraries or APIs.
      </p>
      <pre>
declare module 'my-library' {
  export function greet(name: string): string;
}

const greeting = greet('Alice');
console.log(greeting); // Output: "Hello, Alice"
      </pre>
      <p>
          In this example, a type declaration is used to describe the <code>greet</code> function from the <code>my-library</code>
          module. This allows TypeScript to understand and validate the usage of the function, even though the implementation
          details are not available in the current codebase.
      </p>
  </article>
</section>

<section id="TypeGuardsInTypeScript">
  <h2>Type Guards in TypeScript</h2>
  <article>
      <p>
          Type guards are techniques that allow you to narrow down the type of a value within a conditional statement.
          TypeScript can use these guards to infer more specific types and provide better type checking.
      </p>
      <pre>
function printLength(value: string | number): void {
  if (typeof value === 'string') {
      console.log(value.length); // OK: TypeScript knows it's a string
  } else {
      console.log(value); // OK: TypeScript knows it's a number
  }
}

printLength('hello'); // Output: 5
printLength(42);      // Output: 42
      </pre>
      <p>
          In this example, the <code>typeof</code> check is used as a type guard to determine whether <code>value</code>
          is a string or a number. This allows TypeScript to infer the appropriate type and provide accurate type checking
          within each branch of the conditional statement.
      </p>
  </article>
</section>

<section id="UnionTypesInTypeScript">
  <h2>Union Types in TypeScript</h2>
  <article>
      <p>
          Union types allow you to specify that a value can be of multiple types. This is useful when a function or
          variable can accept more than one type of input.
      </p>
      <pre>
function printLength(value: string | number): void {
  console.log(value.length); // Error: 'length' property does not exist on 'string | number'
}

printLength('hello'); // Output: 5
printLength(42);      // Error: 'length' property does not exist on 'string | number'
      </pre>
      <p>
          In this example, TypeScript throws an error because the <code>length</code> property is not defined for both
          <code>string</code> and <code>number</code> types. To resolve this, you can use type assertions or type guards
          to narrow down the type before accessing the property.
      </p>
  </article>
</section>

<section id="IntersectionTypesInTypeScript">
  <h2>Intersection Types in TypeScript</h2>
  <article>
      <p>
          Intersection types allow you to combine multiple types into a single type that has all the properties and
          methods of each constituent type.
      </p>
      <pre>
interface Printable {
  print: () => void;
}

interface Loggable {
  log: () => void;
}

function processObject(obj: Printable & Loggable): void {
  obj.print();
  obj.log();
}

const obj = {
  print() { console.log('Printing'); },
  log() { console.log('Logging'); }
};

processObject(obj); // Output: "Printing" followed by "Logging"
      </pre>
      <p>
          In this example, the <code>processObject</code> function accepts an object that must have both <code>print</code>
          and <code>log</code> methods. The <code>obj</code> object satisfies these requirements and is successfully processed.
      </p>
  </article>
</section>

<section id="TypeAliasesInTypeScript">
  <h2>Type Aliases in TypeScript</h2>
  <article>
      <p>
          Type aliases allow you to create custom names for types, making complex types more readable and reusable.
      </p>
      <pre>
type Point = { x: number; y: number };

function distance(a: Point, b: Point): number {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return Math.sqrt(dx ** 2 + dy ** 2);
}

const pointA = { x: 0, y: 0 };
const pointB = { x: 3, y: 4 };

const dist = distance(pointA, pointB);
console.log(dist); // Output: 5
      </pre>
      <p>
          In this example, the <code>Point</code> type alias is used to define the shape of a point. The <code>distance</code>
          function takes two points and calculates the Euclidean distance between them.
      </p>
  </article>
</section>

<section id="EnumerationsInTypeScript">
  <h2>Enumerations in TypeScript</h2>
  <article>
      <p>
          Enumerations allow you to define a set of named constants, giving meaningful names to values and improving code
          readability.
      </p>
      <pre>
enum Color {
  Red,
  Green,
  Blue
}

const selectedColor = Color.Green;
console.log(selectedColor); // Output: 1
      </pre>
      <p>
          In this example, the <code>Color</code> enumeration defines constants for different colors. The value of <code>selectedColor</code>
          is set to <code>Color.Green</code>, which is associated with the numeric value 1.
      </p>
  </article>
</section>

<section id="LiteralTypesInTypeScript">
  <h2>Literal Types in TypeScript</h2>
  <article>
      <p>
          Literal types allow you to specify a value that must be an exact match of a specific literal value.
      </p>
      <pre>
function printText(text: 'hello' | 'world'): void {
  console.log(text);
}

printText('hello'); // Output: "hello"
printText('world'); // Output: "world"
      </pre>
      <p>
          In this example, the <code>printText</code> function only accepts the literal values <code>'hello'</code> or <code>'world'</code>.
          Any other value will result in a type error.
      </p>
  </article>
</section>
<section id="GenericsInTypeScript">
  <h2>Generics in TypeScript</h2>
  <article>
      <p>
          Generics allow you to create reusable functions, classes, and interfaces that work with a variety of data types.
          They provide flexibility by allowing you to define placeholders for type information.
      </p>
      <pre>
function identity<T>(arg: T): T {
  return arg;
}

const result = identity(42); // result is of type number
const value = identity('hello'); // value is of type string
      </pre>
      <p>
          In this example, the <code>identity</code> function uses a type parameter <code>T</code> to capture the type of the argument
          and the return value. This allows you to create functions that maintain type information without repeating code.
      </p>
  </article>
</section>

<section id="WorkingWithArraysInTypeScript">
  <h2>Working with Arrays in TypeScript</h2>
  <article>
      <p>
          TypeScript provides type annotations and inference for arrays, allowing you to work with arrays of specific types
          while catching type-related errors.
      </p>
      <pre>
const numbers: number[] = [1, 2, 3, 4, 5];
const words: string[] = ['apple', 'banana', 'cherry'];

function sumArray(values: number[]): number {
  return values.reduce((sum, value) => sum + value, 0);
}

const total = sumArray(numbers); // Output: 15
      </pre>
      <p>
          In this example, the <code>numbers</code> and <code>words</code> arrays are explicitly annotated with their respective types.
          The <code>sumArray</code> function takes an array of numbers and returns their sum.
      </p>
  </article>
</section>

<section id="TupleTypesInTypeScript">
  <h2>Tuple Types in TypeScript</h2>
  <article>
      <p>
          Tuple types allow you to express an array with a fixed number of elements, where each element has a specific type.
          They provide a way to represent arrays with different element types in a type-safe manner.
      </p>
      <pre>
const coordinate: [number, number] = [3, 7];

function printCoordinate(coord: [number, number]): void {
  console.log(`x: ${coord[0]}, y: ${coord[1]}`);
}

printCoordinate(coordinate); // Output: "x: 3, y: 7"
      </pre>
      <p>
          In this example, the <code>coordinate</code> variable is annotated with a tuple type representing a 2D point. The
          <code>printCoordinate</code> function takes a tuple and prints its elements.
      </p>
  </article>
</section>

<section id="EnumsWithStringValuesInTypeScript">
  <h2>Enums with String Values in TypeScript</h2>
  <article>
      <p>
          Enums can have string values instead of numeric values, allowing you to create more descriptive and meaningful
          representations of data.
      </p>
      <pre>
enum Direction {
  Up = 'UP',
  Down = 'DOWN',
  Left = 'LEFT',
  Right = 'RIGHT'
}

const currentDirection = Direction.Up;
console.log(currentDirection); // Output: "UP"
      </pre>
      <p>
          In this example, the <code>Direction</code> enum uses string values to represent directions. The <code>currentDirection</code>
          variable is set to <code>Direction.Up</code>, which is associated with the string value <code>'UP'</code>.
      </p>
  </article>
</section>

<section id="MixinsInTypeScript">
  <h2>Mixins in TypeScript</h2>
  <article>
      <p>
          Mixins allow you to compose classes by combining the functionality of multiple classes. TypeScript provides a way to
          achieve mixins using a combination of inheritance, interfaces, and utility types.
      </p>
      <pre>
class Printable {
  print(): void {
      console.log('Printing...');
  }
}

class Loggable {
  log(): void {
      console.log('Logging...');
  }
}

type MyMixin = Printable & Loggable;

function applyMixin(target: any, mixin: any) {
  Object.assign(target.prototype, mixin.prototype);
}

class Document implements MyMixin {
  // ...
}

const doc = new Document();
doc.print(); // Output: "Printing..."
doc.log();   // Output: "Logging..."
      </pre>
      <p>
          In this example, the <code>Printable</code> and <code>Loggable</code> classes define separate behaviors. The <code>MyMixin</code>
          type represents the combination of these behaviors. The <code>applyMixin</code> function is used to apply mixins to a class.
          The <code>Document</code> class implements the <code>MyMixin</code> interface, inheriting both the <code>print</code> and <code>log</code>
          methods.
      </p>
  </article>
</section>
<section id="NamespacesAndModulesTogether">
  <h2>Namespaces and Modules Together</h2>
  <article>
      <p>
          TypeScript supports both namespaces and modules for organizing code. Namespaces provide a way to group related
          code under a single name, while modules offer a more modern and modular approach to code organization.
      </p>
      <pre>
// Namespace
namespace MyNamespace {
  export function foo() { /* ... */ }
}

// Module
export function bar() { /* ... */ }

// Using both
MyNamespace.foo();
bar();
      </pre>
      <p>
          In this example, <code>MyNamespace</code> is defined using a namespace, and the <code>bar</code> function is defined in a module.
          You can use both constructs together as needed in your codebase.
      </p>
  </article>
</section>

<section id="NamespacesVsModulesInTypeScript">
  <h2>Namespaces vs. Modules in TypeScript</h2>
  <article>
      <p>
          Namespaces and modules have different use cases in TypeScript. Namespaces are suitable for organizing code when working
          with older JavaScript environments or for structuring large codebases, while modules are more suitable for modern
          applications and can offer better encapsulation and maintainability.
      </p>
      <pre>
// Namespace approach
namespace Geometry {
  export interface Point { /* ... */ }
}

// Module approach
export interface Point { /* ... */ }
      </pre>
      <p>
          In this example, both the namespace and module approaches define an interface named <code>Point</code>. The module approach
          provides better isolation and reusability, especially when working with external dependencies.
      </p>
  </article>
</section>

<section id="UsingThirdPartyModulesInTypeScript">
  <h2>Using Third-Party Modules in TypeScript</h2>
  <article>
      <p>
          TypeScript supports the use of third-party libraries and modules in your projects. You can import and use external
          modules to enhance your application's functionality.
      </p>
      <pre>
import * as moment from 'moment';
const today = moment().format('YYYY-MM-DD');
      </pre>
      <p>
          In this example, the <code>moment</code> library is imported as a module. This allows you to use its functions and features
          in your TypeScript code.
      </p>
  </article>
</section>

<section id="DeclarationMergingInTypeScript">
  <h2>Declaration Merging in TypeScript</h2>
  <article>
      <p>
          Declaration merging allows you to extend the types or values of existing TypeScript entities, such as interfaces,
          classes, or functions. This can be useful when working with third-party libraries or adding additional properties
          to existing types.
      </p>
      <pre>
interface Car {
  brand: string;
}

interface Car {
  model: string;
}

const myCar: Car = {
  brand: 'Toyota',
  model: 'Camry'
};
      </pre>
      <p>
          In this example, two separate <code>Car</code> interfaces are merged together to create a single <code>Car</code> interface
          with both <code>brand</code> and <code>model</code> properties.
      </p>
  </article>
</section>

<section id="AmbientDeclarationsInTypeScript">
  <h2>Ambient Declarations in TypeScript</h2>
  <article>
      <p>
          Ambient declarations allow you to describe the shape and behavior of external JavaScript code or libraries in your TypeScript projects.
          This is useful when you're using JavaScript code that doesn't have TypeScript typings.
      </p>
      <pre>
// Declaration for an external library (e.g., jQuery)
declare var $: any;

// Now you can use jQuery in your TypeScript code
$('#myElement').fadeIn();
      </pre>
      <p>
          In this example, the <code>declare</code> keyword is used to create an ambient declaration for the <code>$</code> variable from jQuery.
          This lets you use jQuery functions in your TypeScript code without TypeScript's type checking.
      </p>
  </article>
</section>

<section id="DeclarationFilesInTypeScript">
  <h2>Declaration Files in TypeScript</h2>
  <article>
      <p>
          Declaration files (.d.ts) provide type information for existing JavaScript libraries or modules that don't have built-in TypeScript support.
          These files enable TypeScript projects to understand the shape of the external code and perform type checking.
      </p>
      <pre>
// Example declaration file for jQuery
// jquery.d.ts
declare var $: any;

// Now TypeScript knows about the $ variable
const element = $('#myElement');
      </pre>
      <p>
          In this example, a declaration file named <code>jquery.d.ts</code> declares the <code>$</code> variable as any type. This allows you
          to use the <code>$</code> variable in your TypeScript code with type checking.
      </p>
  </article>
</section>

<section id="WorkingWithPromisesInTypeScript">
  <h2>Working with Promises in TypeScript</h2>
  <article>
      <p>
          Promises are a way to manage asynchronous operations in JavaScript and TypeScript. TypeScript provides built-in support for Promises,
          making it easier to work with asynchronous code.
      </p>
      <pre>
function fetchData(): Promise<string> {
  return new Promise((resolve, reject) => {
      // Simulate an async operation
      setTimeout(() => {
          resolve('Data fetched successfully');
      }, 1000);
  });
}

fetchData()
  .then(data => console.log(data))
  .catch(error => console.error(error));
      </pre>
      <p>
          In this example, the <code>fetchData</code> function returns a Promise that resolves with a string after a simulated asynchronous operation.
          The <code>then</code> method is used to handle the resolved value, and the <code>catch</code> method is used to handle errors.
      </p>
  </article>
</section>

<section id="AsyncAwaitInTypeScript">
  <h2>Async/Await in TypeScript</h2>
  <article>
      <p>
          Async/await is a modern syntax for working with asynchronous code in a more synchronous-looking manner. TypeScript supports async/await
          to simplify handling promises and asynchronous operations.
      </p>
      <pre>
async function fetchData(): Promise<string> {
  const response = await fetch('https://api.example.com/data');
  const data = await response.text();
  return data;
}

fetchData()
  .then(data => console.log(data))
  .catch(error => console.error(error));
      </pre>
      <p>
          In this example, the <code>fetchData</code> function uses the <code>await</code> keyword to pause execution until the promise is resolved.
          This results in cleaner and more readable code when dealing with asynchronous operations.
      </p>
  </article>
</section>

<section id="UsingAsyncFunctionsInTypeScript">
  <h2>Using async Functions in TypeScript</h2>
  <article>
      <p>
          Async functions are a combination of promises and generators, making it easier to write and manage asynchronous code. TypeScript
          provides support for async functions to simplify the handling of asynchronous operations.
      </p>
      <pre>
async function fetchData(): Promise<string> {
  try {
      const response = await fetch('https://api.example.com/data');
      const data = await response.text();
      return data;
  } catch (error) {
      console.error(error);
      return 'An error occurred';
  }
}

fetchData()
  .then(data => console.log(data));
      </pre>
      <p>
          In this example, the <code>fetchData</code> function uses the <code>await</code> keyword within a <code>try</code> block to handle asynchronous
          operations. The <code>catch</code> block handles any errors that occur during the async function's execution.
      </p>
  </article>
</section>

<section id="ErrorHandlingInTypeScript">
  <h2>Error Handling in TypeScript</h2>
  <article>
      <p>
          TypeScript provides mechanisms for handling errors and exceptions in your code. You can use <code>try</code> and <code>catch</code>
          blocks to handle errors and recover from exceptions.
      </p>
      <pre>
try {
  // Code that might throw an error
  const result = 10 / 0; // This will throw a "Division by zero" error
} catch (error) {
  console.error('An error occurred:', error);
}
      </pre>
      <p>
          In this example, the <code>try</code> block contains code that may throw an error. If an error occurs, the <code>catch</code> block
          captures the error and provides an opportunity to handle it.
      </p>
  </article>
</section>
<section id="TypeCompatibilityinTypeScript" >
    <h2>Type Compatibility in TypeScript</h2>
    <article>
        <p>
            TypeScript has a structural type system that focuses on the shape of types rather than their explicit declarations.
            This means that types are considered compatible if their structure matches, even if they have different names.
        </p>
        <pre>
interface Animal {
    name: string;
}

interface Dog {
    name: string;
    breed: string;
}

const myDog: Dog = { name: 'Buddy', breed: 'Labrador' };
const animal: Animal = myDog; // Compatible because structure matches
        </pre>
        <p>
            In this example, even though <code>myDog</code> is of type <code>Dog</code> and <code>animal</code> is of type <code>Animal</code>,
            TypeScript allows the assignment because their structures are compatible.
        </p>
    </article>
</section>

<section id="TypeInferenceWithUnionTypes">
    <h2>Type Inference with Union Types</h2>
    <article>
        <p>
            TypeScript uses type inference to automatically determine the type of a variable based on its value. This is especially
            useful when working with union types, which represent values that can have multiple types.
        </p>
        <pre>
let result: string | number;
result = 'Hello'; // Inferred type: string
result = 42;      // Inferred type: number
        </pre>
        <p>
            In this example, the variable <code>result</code> is of type <code>string | number</code>. TypeScript infers the type based
            on the assigned value.
        </p>
    </article>
</section>

<section id="AdvancedTypesInTypeScript">
    <h2>Advanced Types in TypeScript</h2>
    <article>
        <p>
            TypeScript provides various advanced types that allow you to express complex type relationships and manipulations.
            These include union types, intersection types, type aliases, conditional types, mapped types, and more.
        </p>
        <pre>
type Point = { x: number; y: number };
type Color = 'red' | 'blue' | 'green';
type Shape = Circle | Square;

interface Circle {
    kind: 'circle';
    radius: number;
}

interface Square {
    kind: 'square';
    sideLength: number;
}

type ShapeKind = Circle['kind'] | Square['kind']; // 'circle' | 'square'
        </pre>
        <p>
            In this example, various advanced types are demonstrated, including union types (<code>Point</code>), literal types (<code>Color</code>),
            and discriminated unions (<code>Shape</code>).
        </p>
    </article>
</section>
<section id="ConditionalTypesInTypeScript">
  <h2>Conditional Types in TypeScript</h2>
  <article>
      <p>
          Conditional types in TypeScript allow you to create types that depend on a condition. They are often used with the <code>infer</code> keyword
          to extract type information from other types.
      </p>
      <pre>
type NonNullable<T> = T extends null | undefined ? never : T;
type ExtractArrayType<T> = T extends (infer U)[] ? U : never;

type NonNullableString = NonNullable<string | null | undefined>; // Result: string
type ArrayElementType = ExtractArrayType<number[]>;             // Result: number
      </pre>
      <p>
          In this example, the <code>NonNullable</code> and <code>ExtractArrayType</code> conditional types are demonstrated using the <code>infer</code> keyword.
      </p>
  </article>
</section>
<section id="IndexedAccessTypesInTypeScript">
  <h2>Indexed Access Types in TypeScript</h2>
  <article>
      <p>
          Indexed access types in TypeScript allow you to access the type of a property in a type by using a string or numeric literal type as an index.
      </p>
      <pre>
type Person = { name: string; age: number; };

type NameType = Person['name']; // Result: string
type AgeType = Person['age'];   // Result: number
      </pre>
      <p>
          In this example, the <code>NameType</code> and <code>AgeType</code> are types extracted from the <code>Person</code> type using indexed access.
      </p>
  </article>
</section>
<section id="MappedTypesInTypeScript">
  <h2>Mapped Types in TypeScript</h2>
  <article>
      <p>
          Mapped types in TypeScript allow you to transform properties of a type while preserving their keys and structure.
      </p>
      <pre>
type Optional<T> = { [K in keyof T]?: T[K] };
type Readonly<T> = { readonly [K in keyof T]: T[K] };

type Person = { name: string; age: number; };

type OptionalPerson = Optional<Person>;
type ReadonlyPerson = Readonly<Person>;
      </pre>
      <p>
          In this example, the <code>Optional</code> and <code>Readonly</code> mapped types are used to create new types with optional and readonly properties, respectively.
      </p>
  </article>
</section>
<section id="UtilityTypesInTypeScript">
  <h2>Utility Types in TypeScript</h2>
  <article>
      <p>
          TypeScript provides a set of built-in utility types that simplify common type transformations and manipulations.
      </p>
      <pre>
type Person = { name: string; age: number; address: string };

type PartialPerson = Partial<Person>;
type ReadonlyPerson = Readonly<Person>;
type RecordPerson = Record<string, Person>;
      </pre>
      <p>
          In this example, the <code>Partial</code>, <code>Readonly</code>, and <code>Record</code> utility types are used to transform and manipulate the <code>Person</code> type.
      </p>
  </article>
</section>
<section id="PartialAndReadonlyTypes">
  <h2>Partial and Readonly Types</h2>
  <article>
      <p>
          Partial and Readonly types are utility types in TypeScript that allow you to make properties of a type optional or readonly, respectively.
      </p>
      <pre>
type Person = { name: string; age: number; };

type PartialPerson = Partial<Person>;       // All properties optional
type ReadonlyPerson = Readonly<Person>;     // All properties readonly
      </pre>
      <p>
          In this example, the <code>PartialPerson</code> type has all properties of <code>Person</code> optional, and the <code>ReadonlyPerson</code> type has all properties of <code>Person</code> readonly.
      </p>
  </article>
</section>
<section id="RequiredAndPickTypes">
  <h2>Required and Pick Types</h2>
  <article>
      <p>
          Required and Pick types are utility types in TypeScript that allow you to make properties of a type required or select specific properties, respectively.
      </p>
      <pre>
type Person = { name: string; age?: number; address?: string };

type RequiredPerson = Required<Person>;     // All properties required
type SelectedPerson = Pick<Person, 'name'>; // Select 'name' property
      </pre>
      <p>
          In this example, the <code>RequiredPerson</code> type has all properties of <code>Person</code> required, and the <code>SelectedPerson</code> type only includes the 'name' property from <code>Person</code>.
      </p>
  </article>
</section>
<section id="ExcludeAndExtractTypes">
  <h2>Exclude and Extract Types</h2>
  <article>
      <p>
          Exclude and Extract types are utility types in TypeScript that allow you to manipulate union types by excluding or extracting specific types.
      </p>
      <pre>
type OriginalType = 'a' | 'b' | 'c';
type ExcludedType = Exclude<OriginalType, 'a' | 'b'>; // Result: 'c'
type ExtractedType = Extract<OriginalType, 'b' | 'c'>; // Result: 'b' | 'c'
      </pre>
      <p>
          In this example, the <code>Exclude</code> type removes specified types from a union type, and the <code>Extract</code> type selects specific types from a union type.
      </p>
  </article>
</section>
<section id="NonNullableAndParametersTypes">
  <h2>Non-Nullable and Parameters Types</h2>
  <article>
      <p>
          Non-Nullable and Parameters types are utility types in TypeScript that allow you to manipulate the nullability of types and extract parameter types from function types.
      </p>
      <pre>
type NullableString = string | null;
type NonNullableString = NonNullable<NullableString>; // Result: string

type MyFunction = (a: number, b: string) => boolean;
type FunctionParams = Parameters<MyFunction>; // Result: [number, string]
      </pre>
      <p>
          In this example, the <code>NonNullable</code> type removes the <code>null</code> type from a union, and the <code>Parameters</code> type extracts the parameter types of a function type.
      </p>
  </article>
</section>
<section id="OmitAndReturnTypeTypes">
  <h2>Omit and ReturnType Types</h2>
  <article>
      <p>
          Omit and ReturnType types are utility types in TypeScript that allow you to omit properties from an object type and extract the return type of a function type.
      </p>
      <pre>
type OriginalType = { a: string; b: number; c: boolean };
type OmittedType = Omit<OriginalType, 'b'>; // Result: { a: string; c: boolean }

type MyFunction = () => string;
type ReturnTypeOfFunction = ReturnType<MyFunction>; // Result: string
      </pre>
      <p>
          In this example, the <code>Omit</code> type removes the specified property from an object type, and the <code>ReturnType</code> type extracts the return type of a function type.
      </p>
  </article>
</section>
<section id="PolymorphicThisTypes">
  <h2>Polymorphic this Types</h2>
  <article>
      <p>
          Polymorphic this types in TypeScript allow you to create methods that return the type of the class or its subclasses, enabling better chaining and method call behavior.
      </p>
      <pre>
class Chainable<T> {
  constructor(public value: T) {}

  map<U>(fn: (x: T) => U): Chainable<U> {
      return new Chainable(fn(this.value));
  }
}

const result = new Chainable(10)
  .map(x => x * 2)
  .map(x => x.toString());

// 'result' is of type Chainable<string>
      </pre>
      <p>
          In this example, the <code>Chainable</code> class uses a polymorphic this type to enable method chaining with proper type inference.
      </p>
  </article>
</section>
<section id="TypeCastingInTypeScript">
  <h2>Type Casting in TypeScript</h2>
  <article>
      <p>
          Type casting in TypeScript allows you to explicitly specify the type of a value, overriding the type inference.
      </p>
      <pre>
const value: any = 'Hello, TypeScript!';
const length: number = (value as string).length; // Explicit type casting
      </pre>
      <p>
          In this example, the <code>as</code> keyword is used for type casting to ensure that the <code>value</code> is treated as a string type.
      </p>
  </article>
</section>
<section id="TripleSlashDirectivesInTypeScript">
  <h2>Triple-Slash Directives in TypeScript</h2>
  <article>
      <p>
          Triple-slash directives in TypeScript are comments used to provide instructions to the TypeScript compiler.
      </p>
      <pre>
/// <reference types="module-name" />
/// <reference path="path-to-definition-file.d.ts" />
      </pre>
      <p>
          In this example, triple-slash directives are used to reference external module declarations or definition files.
      </p>
  </article>
</section>
<section id="ConfiguringTsconfigJson">
  <h2>Configuring tsconfig.json</h2>
  <article>
      <p>
          The <code>tsconfig.json</code> file is used to configure TypeScript compiler settings for a project.
      </p>
      <pre>
{
  "compilerOptions": {
      "target": "ES6",
      "module": "CommonJS",
      "outDir": "./dist",
      "strict": true
  },
  "include": ["./src/**/*"],
  "exclude": ["node_modules"]
}
      </pre>
      <p>
          In this example, compiler options, inclusion patterns, and exclusion patterns are configured in the <code>tsconfig.json</code> file.
      </p>
  </article>
</section>
<section id="StrictNullChecksInTypeScript">
  <h2>Strict Null Checks in TypeScript</h2>
  <article>
      <p>
          Strict null checks in TypeScript help prevent null and undefined values from causing runtime errors.
      </p>
      <pre>
let value: string | null = null;

// Without strict null checks:
const length: number = value.length; // Error at runtime

// With strict null checks:
const length: number = value.length; // Compile-time error
      </pre>
      <p>
          In this example, strict null checks prevent accessing properties of a potentially null value.
      </p>
  </article>
</section>
<section id="UsingTypeScriptWithReact">
  <h2>Using TypeScript with React</h2>
  <article>
      <p>
          TypeScript can be used with React to enhance type safety and provide better development experiences.
      </p>
      <pre>
interface Props {
  name: string;
}

const Greeting: React.FC<Props> = ({ name }) => {
  return <div>Hello, {name}!</div>;
};

// Usage
const App: React.FC = () => {
  return <Greeting name="TypeScript" />;
};
      </pre>
      <p>
          In this example, TypeScript interfaces are used to define component props, enhancing type checking and documentation.
      </p>
  </article>
</section>
<section id="ReactWithTypeScriptProps">
  <h2>React with TypeScript Props</h2>
  <article>
      <p>
          TypeScript enables better type definitions for React component props.
      </p>
      <pre>
interface Props {
  name: string;
  age: number;
}

const Person: React.FC<Props> = ({ name, age }) => {
  return <div>{name}, {age} years old</div>;
};
      </pre>
      <p>
          In this example, TypeScript interfaces are used to define component props with specific types.
      </p>
  </article>
</section>
<section id="ReactWithTypeScriptState">
  <h2>React with TypeScript State</h2>
  <article>
      <p>
          TypeScript allows you to define and infer the state types in React components.
      </p>
      <pre>
import React, { useState } from 'react';

interface CounterState {
  count: number;
}

const Counter: React.FC = () => {
  const [state, setState] = useState<CounterState>({ count: 0 });

  return (
      &lt;div>
          Count: {state.count}
          &lt;button onClick={() => setState({ count: state.count + 1 })}>Increment&lt;/button>
      &lt;/div>
  );
};
      </pre>
      <p>
          In this example, TypeScript is used to define the state type as <code>CounterState</code> and to infer the type of the <code>state</code> variable.
      </p>
  </article>
</section>

<section id="ReactWithTypeScriptHooks">
  <h2>React with TypeScript Hooks</h2>
  <article>
      <p>
          TypeScript provides type inference and checking for React hooks.
      </p>
      <pre>
import React, { useState } from 'react';

const Counter: React.FC = () => {
  const [count, setCount] = useState<number>(0);

  return (
      &lt;div>
          Count: {count}
          &lt;button onClick={() => setCount(count + 1)}>Increment&lt;/button>
      &lt;/div>
  );
};
      </pre>
      <p>
          In this example, TypeScript type annotations are used with the <code>useState</code> hook to define the state type.
      </p>
  </article>
</section>

<section id="ReactWithTypeScriptForms">
  <h2>React with TypeScript Forms</h2>
  <article>
      <p>
          TypeScript improves form handling in React components.
      </p>
      <pre>
interface FormData {
  username: string;
  password: string;
}

const LoginForm: React.FC = () => {
  const [formData, setFormData] = useState<FormData>({ username: '', password: '' });

  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
      const { name, value } = event.target;
      setFormData({ ...formData, [name]: value });
  };

  return (
      <form>
          <input type="text" name="username" value={formData.username} onChange={handleInputChange} />
          <input type="password" name="password" value={formData.password} onChange={handleInputChange} />
          <button type="submit">Login</button>
      </form>
  );
};
      </pre>
      <p>
          In this example, TypeScript types and event type annotations are used for handling form inputs.
      </p>
  </article>
</section>
<section id="ReactWithTypeScriptContext">
  <h2>React with TypeScript Context</h2>
  <article>
      <p>
          TypeScript improves type safety in React context usage.
      </p>
      <pre>
interface User {
  id: number;
  name: string;
}

const UserContext = React.createContext<User | null>(null);

const App: React.FC = () => {
  const user: User = { id: 1, name: 'John' };

  return (
      <UserContext.Provider value={user}>
          {/* ... */}
      </UserContext.Provider>
  );
};
      </pre>
      <p>
          In this example, TypeScript is used to define the type of the context value and ensure type correctness.
      </p>
  </article>
</section>
<section id="UsingTypeScriptWithNodejs">
  <h2>Using TypeScript with Node.js</h2>
  <article>
      <p>
          TypeScript can be used to develop server-side applications with Node.js.
      </p>
      <pre>
// app.ts
import express from 'express';

const app = express();
app.get('/', (req, res) => {
  res.send('Hello, TypeScript with Node.js!');
});

app.listen(3000, () => {
  console.log('Server is running on port 3000');
});
      </pre>
      <p>
          In this example, TypeScript is used to create a simple Express.js server.
      </p>
  </article>
</section>
<section id="IntegratingTypeScriptWithExpressjs">
  <h2>Integrating TypeScript with Express.js</h2>
  <article>
      <p>
          TypeScript can be integrated with Express.js for a more robust server-side development experience.
      </p>
      <pre>
// app.ts
import express, { Request, Response } from 'express';

const app = express();
app.get('/', (req: Request, res: Response) => {
  res.send('Hello, TypeScript with Express.js!');
});

app.listen(3000, () => {
  console.log('Server is running on port 3000');
});
      </pre>
      <p>
          In this example, TypeScript types are used to enhance Express.js request and response objects.
      </p>
  </article>
</section>
<footer>
  <button class="abc" > <a href="Python.html">Learn Python</a> </button>
<p>Copyright © Shipyard Gamerz. All rights reserved.</p>
</footer>
    </main>
  </body>  
</html>